				Kotlin
.....................................................................................

What is Kotlin?
    Kotlin is the programming language for JVM.

JVM is runtime to run java applications.

JVM is abstract computer which solves the problem of platform independant.

One source and one Compiled code can be ported  on multiple platforms(os/hardware)

What is java?
  You mean java is programming language but not.
Java is technology, technolgy means solves the pratical problems.

Java technology means many things

1.java programming language
2.tools
   compilers,debuggers,libs,apis....
3.runtime - jre
    -JDK

Java Programming language offers the source code , compiler compiles the source code into object code(byte code).

How java technology works? who controls java technology?

JCP - java community process who standarize the java technology.

All java versions and enchancments certified by JCP only...

JCP classifies java into there major editions

1.JAVA SE
2.JAVA EE
3.JAVA ME

JEP - This is committe formed by oracle
.....................................................................................
			JSR 223 :Scripting for The Java TM Platform
....................................................................................
JSR 223 spec was released on June-10-2003

Before this specification, only one programming language was there for JVM- Java Programming language.

The spec aim is to introduce new languages for JVM - Poly glot languages for Java Platform.

Based on this spec, the first language other than java pl, was created  for JVM-Groovy Programming langugage.
.....................................................................................
			    JSR 223 Poly glot language implementation


        java pl    Groovy   Scala  Kotlin Clojure XX
         -------------------------------------------
			 |
		      byte code
                         |
                        jvm



The programs are developed using different styles.

Programming styles:

1.Object oriented
2.Functional programming
3.Procedural
4.Rule based 
etc....

Any language follows any of one of the style or multi style(style).
C is procedural language-single style language.
c++ is object oriented language-single style language

java was object oriented programming - single style

Java is object oriented,functional style programming languge- multi style.

Kotlin is object oriented, functional style programming language...


Language is classified based on types(data types)
.................................................

1.strongly typed /static typed
   The type of variable is decided during compile time.
   int a=10;
   a="hello"
2.weak typed/dynamic typed
  The type of variable is decided during runtime time.
  var a =10
  a ="hello"

Kotlin is dynamic and strongly typed language.
...................................................................................

Programming language
 =>GPL - General Purpose programming language
     language used to build any type of apps
 =>DSL -  Domain specific language
     language used to build sepcific types of apps- html,css

kotlin helps to build dsl code...

DSL code is more declarative 
 
  move left and move right - dsl code
  find sqrt of 10 - dsl code
  take 1 pile every day at morning 7 am  

....................................................................................

Programming methodlogy

1.imperative programming
    => any program there is two aspects
        ->infra code
        ->application logic
    what is it? and how is it?

2.declarative programming
   focus only application logic
   more readable
   less boilerplate 
   less code maintaince because less code
  eg:
    list.sort.filter.map.find.flaten

Kotlin is more declarative programming  language.
.....................................................................................
	 "Kotlin helps to build more declarative, dsl , functional,object oriented          apps"


Kotlin language is highly multi purpose programming language
 - To build mobile apps -> multi platform mobile - android and ios apps.
 - To build server side apps - microservices,RESTFull apis,dynamic web apps..
 - To build platform native apps like c++...


Learning Path:
1.language fundamentals
2.object oriented programming
3.functional programming
4.Exception handling
5.Data structures
6.Concurrency - Co-routines
7.Async programming / Non Blocking apps
8.How to build DSL

Frameworks:
1.web frameworks
2.android
3.Front End 
....................................................................................
				Language fundamentals
.....................................................................................

We are going to build console based Kotlin apps.

Step to create Kotlin project.

You can use any build system to create kotlin project
Maven or Gradle.

Every Kotlin program is saved With "FileName.kt".

Unlike java kotlin programs need not be started with classes, you can start with main method(function).

Kotlin Programming style:

1.file based/script based
2.class based - oo style

How to declare functions in kotlin?

 fun functionName(arg){
   //function body...
 }
Every kotlin program begins with "main" function...

in java : System.out.println()

In Kotlin ; is optional

HelloWorld.kt

fun main(){
    println("Hello Kotlin")
}
....................................................................................
Language Fundamentals:

1.Comments
  Single line comment
	//
  Mutli line comment
	/**
        /**
/**
 * Every Kotlin program starts with main function.
 * In Kotlin ; optional
 */
fun main(){
    //which prints Hello message
    println("Hello Kotlin")
}
..................................................................................
Program means collection of instructions.

instrcutions -(information + how the information is stored,processed,reterived)
information is nothing but data.

How to store data inside computer using programs?

we need to store in memory address, in order to store we need handle

variable: it is handle to store data.

Data:
 -simple data - atomic data - primtive data
  eg:10 -
any data can be broken into smaller unit.

Numbers:
   1.whole number
       -binary,oct,hexa
   2.decimal numbers
      - float


Abstract data types:
   In the begining of programming only basic were used by languages like numbers,characters.
   How to create our own type system- Type of data - Custom Types...

struct,union - c implemnetation of abstract types

Any abstract types are built on the top of built in types.
 
 struct Employee = {numbers,characters}

After some time new type creation syntax introduced "class"

 class Employee {
    numbers
    characters
 }
...................................................................................

Type - Data type
 -primtives
 -Complex type/Custom Type/Reference Type

Variable
 -Holder to hold any type 
Literal
 -Values(primitvies,Complex values)

In kotlin types are dervied from java language.

Java Primtive Types:
1.numbers
 -byte,short,int,long
 -float,double
2.char
3.boolean

In Kotlin you cant use primtives type directly... rather you have to use always "Complex type" - Reference Type

In Kotlin , every thing is Object.

variables are introduced using keywords

-var
-val

variable declaration:
 
 var | val | withoutanyKeyword variableName:Type = literal
 
//types
fun main() {
    //int a=10
    var b: Byte = 90 // size is 1 byte
    var s: Short = 90 //2 bytes
    var i: Int = 10 // 4 bytes
    var lng: Long = 100000 // 8 bytes

    println("Byte" + b)
    println("Short " + s)
    println("Int " + i)
    println("Long " + lng)
   

}

Type inference:
 The type of variable is calculated based on the literal size.

var speed =100
 here the type of speed is calculated according to value
 by default Int type is assigned.

fun main() {
    //type inference demo
    var speed = 100
    var lightSpeed = 100000000888
    println("Speed" + speed)
    println("Light Speed " + lightSpeed)
    //decimals - double
    var stockValue = 100.89 //double
    //Float
    var price: Float = 10.56f
    var lat = 10.56f
    //double
    var isActive = true
    val isEnabled: Boolean = false
}
.....................................................................................
			 Static Typed language or Dynamic typed Language

Static type:
int a =10;
a=90; // it is valid
a=true //it is invalid - compile time error

Dynamic typed
in Js
 let a =10;
 a =100 //valid
 a=true //valid
In groovy
 def a =10
  a=10 //valid
  a=true //valid


Kotlin language is "strongly typed/Static typed" language, even though language looks like without type, but the type is infered
fun main(){
    var a =10
    println("A " + a )
    a=90
    println("A " + a )
    //a=true // invalid
    println("A " + a )

}
............................................................................

Strings :
 String is collection of unicode characters
 String Object 
 Strings are declared  with "" , """

Strings are concated with  + -> traditonal style

Strings are represented with "String Templates" - String interploation.

 "$variable" / "${}"

fun main() {
    //string declaration
    var firstName: String = "Subramanian"
    var lastName = "Murugan"

//String concatnation
    //var fullName = firstName + " " + lastName
    var fullName = "$firstName $lastName"
    println("Name is ${fullName}")
}
..................................................................................
				Multi Line Strings
...................................................................................

java style
//multi line strings -  java style
fun main() {
    val doc = "<html>" +
            "<head>" +
            "<title>Home</title>" +
            "</head>" +
            "<body>" +
            "</body>" +
            "</html>"
    println(doc)
}

Kotlin style:
   """
//multi line strings -  java style
fun main() {
    val doc = "<html>" +
            "<head>" +
            "<title>Home</title>" +
            "</head>" +
            "<body>" +
            "</body>" +
            "</html>"
    println(doc)
    val title="google"
    val newDoc = """
       <html>
          <head>
                <title>${title} Home</title>
          </head>
        <body>
            <h1>welcome to Kotlin</h1>
        </body>
    """.trim()
    println(newDoc)
}
...................................................................................
				Operators
....................................................................................

All operators supported by java  , supported by kotlin as well.

Types of operators
1.arithmetic operators
2.conditional operators
3.logical operators
//operators
fun main() {
    //arithmetic operators
    var a = 10
    var b = 5
    var c = a + b
    println("Add $c")
    c = a - b
    println("Substract $c")
    c = a * b
    println("Multiplication $c")
    c = a / b
    println("Division $c")
    //augmented operators
    var counter = 1
    counter += 1
    println("Counter $counter")

    //logical operators: works based on boolean expressions
    var isValid = true
    var isEnabled = false
    var res = isValid && isEnabled
    println("Result is $res")
    //comparasional operators

    var x = 100
    var y = 200
    //structural equals
    var isEqual = x == y
    println ("Is Equal $isEqual")
    //reference equal
    var str = "hello"
    var strCp= str // here str and strCp points the same mememory address

    var refEqual = str == strCp
    println("Reference Equal $refEqual")

    //comparsional operators
    var isBig = a >b
    println("Is Big $isBig")

}
.....................................................................................
			 conditional work flow
.....................................................................................
conditions: - if

In kotlin, "if" is an expression.
it can return a value like functions.
so in kotlin there is no need for tenary operator.
(condtion ? truthy:falsy)- similar construct if expression provides

fun main() {
    var a = 10;
    var b = 20
    var max = a
    //traditional style
    if (a < b) {
        max = b
    }
    println("Max $max")
    //kotlin expression style
    if (a < b) max = b //here we return max variable
    println("Max $max")
    //if ..else
    //tradtional style
    if (a > b) {
        max = a
    } else {
        max = b
    }
    println("Max $max")
    //expression style
    //here initialize the a value to max variable if condition is true else initialize the b value
    max = if (a < b) a else b
    println("Max $max")

    var isValid = false

    var res = if (isValid) "Greet" else "GoodBye"
    println(res)

    //block of code -logic and return some value

    //Note: we must have else block: which is mandatory
    res = if (isValid) {
        println("More code ")
        var firstName = "Subramanian"
        "welcome $firstName"
    } else {
        var lastName = "Murugan"
        "how are you $lastName"
    }
    println(res)

}
.....................................................................................
When expression:
...............
 When is similar to if expression, but when defines a condtions with multiple branches. which is similar to switch statement...


fun main() {
    //simple when expression
    var x = 10
    when (x) {
        1 -> println("x is 1")
        2 -> println("x is 2")
        else -> println("No Match found")
    }
    //either this or that
    var y = 10
    when (y) {
        0, 10 -> println("Y value is 0 or 1")
        else -> println("other wise")
    }
    //range operator
    var z = 10;
    when (z) {
        in 1..100 -> println("Z is part of this range")
        !in 1..100 -> println("Z is out of Range")
    }
    //return result from the when expression
    var isLoggedIn = false
    var status = when (isLoggedIn) {
        true -> "LoggedIn"
        else -> "Not LoggedIn"
    }
    println(status)
    //when without arg:
    //if no arg is supplied, the branch conditions are simply boolean expression, and a branch
    //executed when its condition is true.

    var num = 3
    var isEvenOrOdd = when {
        num % 2 == 0 -> "Even"
        num % 2 != 0 -> "Odd"
        else -> "No Match Found"
    }
    println(isEvenOrOdd)


}
....................................................................................
				Loops
...................................................................................
Loops:
 for
 range
 while
 do...while
fun main() {
    //range
    for (count in 1..4) {
        println("Count $count")
    }
    //reverse order
    for (count in 5 downTo 1) {
        println("Counter downwards ${count}")
    }
    //step by
    for (count in 1..100 step 2) println(count)
    for (count in 100 downTo 100 step 2) println(count)

    //until
    println("until")
    for (count in 5 until 10) println(count)

    //while loops
    var x = 1
    while (x <= 10) {
        println("x $x")
        x++
    }

}
...................................................................................
				Functions
..................................................................................

What is function?
  The term function is derived from the mathmetics.
  The function represents unit of exectution.
  The function is building block of computer system itself.
    
Types of function with respect to declaration and execution:

1.passive functions
2.active functions

every program is running on runtime(jvm).

JVM arch:
 JVM is a process according to os.

Every process has arch.
Process has three segments
 -Heap
 -Stack
 
Program Data/Method area :
   The passive instructions are stored.
  All functions are stored/initalized inside in this area
  All static variables are initalized inside method area
  All literals(values) are initalized inside constant pool inside method area

All function declarations are stored inside method area only.
.....................................................................................
			 Runtime Representation of functions
....................................................................................

In programs runtime representation means, which should be accessed by cpu,memory should be allocated inside main memory.

Every function must be allocated on RAM, so that it can be accessed by CPU.

declaration
fun main(){

 println()

}

execution
main() ----> we have to allocate memory on ram---|

When function is called, the function is pushed into stack.

stack is last in first out ds.

The runtime starts allocating memory,which is called as "Stack Framework".

Stack frame is runtime representation of any function at any time of time.

After execution of stack frame it is removed from memory, so that other frames will start

getValue()---frame is created---frame is running---frame is removed|
sayHello()---frame is created---frame is running---frame is removed|
.....................................................................................
			  Kotlin functions
....................................................................................

Kotlin supports different functions

1.normal functions
2.infix function
3.local function
4.member function
5.Tail Recursive function
6.inline function
7.suspend function
8.operator function
9.lambda functions


1.normal function.
 -how to declare
 -how to invoke 
 -args and parameters
 -types and parameters
 -return values and its types

//every kotlin begins with main function
fun main() {
    //invoke function
    sayHello()
    add()
}

//normal function
fun sayHello() {
    //function body
    println("Hello");
    //simulating the current frame,takes much time
    Thread.sleep(10000)
}

fun add() {
    var a = 10
    var b = 20
    var c = a + b
    println("The Result is $c")
}
....................................................................................
			Function args and Parameters

Args are place holder which hold values-variables
Parameters are values which to be passed to the function

Simple args and parameters:

package  com.mycom.func.args

fun main() {
    //"Hello" is parameter
    sayHello("Hello")
    //call
    add(1, 2)
    //what if i dont pass parameters
    add();
}

//message is arg
fun sayHello(message: String) {
    println(message)
}

//default args
fun add(a: Int = 0, b: Int = 0) {
    var c = a + b
    println("The Result is $c")
}
.....................................................................................
			More Parameters -Named Parameters
.....................................................................................

fun main() {
    format("Hello", true, false, ',')
    //pass few parameters
    format(str = "Welcome", wordSeparator = ';', normalizeCast = true)
    //if no default args , that is treated as "mandatory parameter"
    //format(wordSeparator = ';', normalizeCast = true)
    format(str = "How are you ?")
    //pass any type of value which is eq to Object o in java.
    accept("Hello")
    accept(100)
    accept(89.45f)
    accept(true)
    accept(3434.89)

}

fun format(
    str: String,
    normalizeCast: Boolean = false,
    upperCaseFirstLetter: Boolean = false,
    wordSeparator: Char = ' '
) {
    println("$str $normalizeCast $upperCaseFirstLetter $wordSeparator")
}

//Object o  = new Employee()
//Object o = 10(new Integer(10)

//how to pass different types of values
fun accept(myVar: Any) {
  println("$myVar")
}
.....................................................................................
			How to return value from the function
.....................................................................................
In kotlin function returns  any object, if function does not return any thing which is called "Unit".
The "Unit" is type with only one value-Unit.
package com.mycom.func.returns


fun main() {
    var message = sayHello()
    println(message)
    println(add(10, 10))
    doStuff()
    doStuffOne()
}

fun sayHello(): String {
    return "Hello"
}

fun add(a: Int = 0, b: Int = 0): Int {
    return a + b
}

//not return any value
fun doStuff():Unit {
    println("do Stuff")
   // return ; return statement is optional
}

fun doStuffOne() {
    println("do Stuff")
    // return ; return statement is optional
}
.....................................................................................
			Single-Expression Function
....................................................................................
When a function returns a single expression,the curly braces can be omitted and the body is specified after = symbol.

package com.mycom.func.returns


fun main() {
    println(sum(10, 10))
    println(getValue())
    println(getStock(100))
}

//normal return syntax
//fun sum(a: Int = 0, b: Int = 0): Int {
//    return a * b
//}
//function expression syntax:
//here we can omit curly braces and return statement
//fun sum(a: Int = 0, b: Int = 0): Int = a * b
//even we can omit return type
fun sum(a: Int = 0, b: Int = 0) = a * b

//function returns literals
fun getValue() = 100
//function returns single args
fun getStock(value: Int = 0) = value
var args: Variable args:
 The function receives more parameters, but we dont know fixed no args

fun main() {
    logger("Employee.kt", "Warning", "save method is called")
    logger("Employee.kt", "Error", "remove method throws Error", "402")
}

fun logger(vararg args: String) {
   for (arg in args) println(arg)
}

fun format(
    str: String,
    normalizeCast: Boolean = false,
    upperCaseFirstLetter: Boolean = false,
    wordSeparator: Char = ' '
) {
    println("$str $normalizeCast $upperCaseFirstLetter $wordSeparator")
}

..........................

..................................................................................	
				null
.................................................................................

What is null?
 Null itself is value even it is called "Object".
 Object means memory which has data.

https://en.wikipedia.org/wiki/Null_pointer

class Order{
//instance reference variable  ----part of heap defintion
   Product p = new Product()
}
class Product {

}
 
static void createInstance(){ 
  //local reference variable
  Order o = new Order()
}

public static void main(){ ---------->stack--frame -----

   createInstance()
}
.....................................................................................
			How to handle null

Null  reference is unavoidable in any object oriented systems, handling null is more challange.
How to handle null very safely?
 Kotlin like languages handles null very effieciently wihout crashing the system.
 Kotlin handles null positively, if there is null, we can give alternate values.

In java , the methods,properties access are verified during compile time, during runtime only , invocations are verfied.

package com.mycom.nullrefdemo;

public class NullDemo {
    public static void main(String[] args) {

        //during compile time the compiler checks always left side
        //during runtime  the runtime checks always right side
        String str = null;
        System.out.println(str.length());
      //  System.out.println(str.doStuff());
    }
}

In Kotlin "null" is verfied during compile itself , so that your code will be more safer during development.

App never crash because of null errors in runtime.

 
In java null is handled

A a=null;
if(a!=null){
  //do this
}else{
  //dont do
}

Kotlin and Null:
1.kotlin variables never allows null by default 

fun main(){
    var firstName:String = null
}
This code cause compile time error
 Null can not be a value of a non-null type String

fun main(){
    //var firstName:String = null
    var firstName:String = ""
    firstName =null
}
This code also causes error.

Some times we cant avoid having null values. How to declare null in Kotlin?
What if i want nullable value?

To declare  nullable variable.
  
 var variableName:Type? = null
 
package com.mycom.nullrefdemo


fun main() {
    //var firstName:String = null
//    var firstName:String = ""
//    firstName =null
    //Nullable: ability to hold null value
    var firstName: String? = null
    println(firstName)
}

.....................................................................................
				What if i access any property on null
.....................................................................................

package com.mycom.nullrefdemo

fun main() {
    var firstName: String? = null
    //handling null
    //way1 : java style using if
    if (firstName != null) {
        println("FirstName size ${firstName.length}")
    } else {
        println("FirstName variable having null value")
    }
    //way 2 : solution 2 : using safe navigation operator
    println(firstName?.length)
    println("Hello")

    //way 3: solution 3: : using Elvis Operator :  if there is null, if you access property
    //on null, it gives you null as output, if you want some meaningfull default values we can use
    //Elvis operator

    var length = firstName?.length ?: 0
    println("String length is $length")

    //way 4: solution 4: For some other reason, if you want "Runtime Exception", how to throw runtime
    //Exception
    println("Boom! ${firstName!!.length}")

}

.....................................................................................
				Functions and Nullable value
.....................................................................................
fun main() {
    //you have to pass value
    sayHello("Subramanian")
    sayHello(null)
    sayHello();


}

fun sayHello(firstName: String?="") {
    println("Hello ${firstName ?: ""} and its length is ${firstName?.length ?: 0}")
}
.....................................................................................
			  Functional Programming
....................................................................................

What is functional Programming?
   Functional programming is one the programming style for building apps.

Functional programming principles and patterns implemented from the mathematics called "Lambda Calculus " -λ-calculus

Lambda calculus (also written as λ-calculus) is a formal system in mathematical logic for expressing "computation based on function abstraction and application using variable binding and substitution"

It is a universal model of computation that can be used to simulate any Turing machine.

It was introduced by the mathematician Alonzo Church in the 1930s as part of his research into the foundations of mathematics.

Turning machine is abstract computer which talks about how to "mutate state" / "manipulate state"

Draw back of Turning machine of Alan Turning:
............................................

1.State Mutation -  mutable state
  

According to lambda calculs what is function?

    "unit of computation" -  having expressions and variables and its values

 f= {
   c= a + b
  }

Lambda calculs offered new idea for state mutation
  "Pure function"

pure function:

A.if function receives input, it never modifes the input parameters rather it returns same.
  
    fun myFun(a:Int){
       return a
    }
    myFun(10)

if function does not modify the input parameter that function is not pure rather impure function.
 
    fun myFun(a:Int){
          return a*10
    }
    myFun(10)
Side Effect:
   if function changes input parameter
   if function does some io operation
   if function changes the local variable with input parameter

if function does the above things, the function is causing side effects- That is called impure function.

B.if function receives input what if i want to modify the input,"dont override the orignial Memory Address", rather copy that value into new memory address and keep the updated value - "Immutable" 

https://www.youtube.com/watch?v=eis11j_iGMs
https://www.youtube.com/watch?v=3VQ382QG-y4
.....................................................................................
		
Lambda calculs and Computer programming language:
.................................................

1.Lisp
2.CommonLisp
3.Lisp For JVM -Clojure 
4.Haskell
5.javascript 
6.JVM
   Groovy,scala,kotlin,java 8 some what,clojure.....


Principles of functional Programming

1.Functions are first class citizines
   Higher order functions
2.Referential transparency
3.pure function
    -side effects,immutablity
4.No Loops  rather recurrsive functions

.....................................................................................
				purely functional 
				    and 
                                functional style


purely functional programming language means, the language implements 100 % all fp principles 
functional style programming language, only implements partial principles.

Kotlin is functional style programming language,object oriented programming principles
.....................................................................................

Kotlin functional Implementation:

1.Function is first class citizens

What is first class citizen (special):
 
  -functions are passed around (in ,out)

This means the language supports passing function as arguments to other function,
returning them as the values from functions , and assigning them to variables or storing them in data structure.

"functions are literal,means values like int ,double string"

 var a =10;
  here a is variable
  here 10 is value(literal)

var myJob = fun doStuff(){}

 Kotlin functions are first class, which means that they can be stored in variables,passed inside ds,passed as params, return them from other functions.

Higher Order function:
  
   First class functions are ncessity for the functional programming style, in which the use of higher order functions is a standard practice.

In Mathmatics and computer science, a higher order function is a function that does the following things

1.takes one or more function as arg
2.returns a function as its result.

can i say this fun is higher order fun?

fun map(){

}
No, because it does not follow the thumb rule of higher order function.
....................................................................................
		  Since Kotlin static typed language, we need to tell the 
			  "type of Itself"


fun map(FunctionType){

}
In kotlin , every thing is object, FunctionType itself is object behind the scene.
....................................................................................
				Kotlin Function Types
..................................................................................

1.(T)->T 
  eg:
   (Int)->Int
   (Int)->String
2.(T1,T2)->T3
   (Int,Int)->Int
   (Int,Int)->String
3.(T)->Unit
   (Int)->Unit
   ()->Unit

fun map((T)->T){

}
Rules:
1.All function types have a parenthesized types list and return type.  
  (A,B)->C
2.Function type can optionally have have an additional "Receiver" type,
  Which is represented a dot in the notation.

  "ReceiverObject".(B,C)->D
    
    A.(B,C)->D
   
  A- Receiver Object
  B,C args
  D- Return type
3.Incase of async programming, in order to represent "callbacks/listener" functions    are represented as suspend function

  suspend (A,B)->D
  suspend A.(B,C)->D
   
EG:
  (a:Int,b:Int)->Shape

 Here no variables are nullable, what if i want nullable representation...

 ((A,B)->c)?
 (A.(B,C)->D)?



Function declaration with variable
....................................

 action:()->Unit

 action is just variable, 
 ()->Unit - function type

 a:Int ====== action:()->Unit


Function literals:

 In functional programming "functions are values(literals)/expressions", can be stored into a variable.
  Since function stored inside variable, that variable can be used to invoke that function.
 
  var sayHello: () -> Unit = fun() {
        println("Hello")
    }
    sayHello()

Here 
 sayHello is just variable only
 () -> Unit is type of that function.

sayHello() - function reference.

   fun() {
        println("Hello")
    }
Here no function name so that it is called "anonyoumus functions (function without name)" 

package com.mycom.functionalprogramming.hof


fun main() {
    //a is variable
    //10 is value(literal)
    var a: Int = 10 // explicit type is declared
    println("a $a")
    var b = 20 // Type inference is enabled

    //function declaration with Explicit type
    var sayHello: () -> Unit = fun() {
        println("Hello")
    }
    sayHello();

    //function declaration with "type inference"
    var sayHai = fun() {
        println("Hai")
    }
    sayHai()
    //An anonymous function is not allowed to specify default values for its parameters
//    var add: (Int, Int) -> Int = fun(a: Int=0, b: Int=0): Int {
//        return a + b
//    }
    var add: (Int, Int) -> Int = fun(a: Int, b: Int): Int {
        return a + b
    }
    println(add(10, 10));

    var substract = fun(a: Int, b: Int): Int {
        return a - b
    }
    println(substract(10, 4));

    //what if the parameter is nullable
    var accept: ((String) -> String)? = fun(message: String): String {
        return "Hello $message";
    }
    //if function literal is called with nullable, you cant call directly
    //Surrondwith Null Check
    if (accept != null) {
        println(accept("Subramanian"))
    }
    //Every function type is Object, In kotlin every thing is object.

    //there is method called invoke, can be used to invoke any anonymous functions
    println(substract.invoke(10, 23));
    println(accept?.invoke("Geetha Subramanian"))

    //With Type inference
    var display = fun(message: String?): String? {
        return "Hello $message";
    }
    println(display?.invoke("Geetha Subramanian"))

}
....

Higher Order function: function as parameter:

package com.mycom.functionalprogramming.hof

fun add(a: Int, b: Int) {
    println("$a $b")
}

//Higher order function.
fun sayGreet(action: () -> Unit) {
    action()
    //  action.invoke()
}

fun adder(action: (Int, Int) -> Unit) {
    action(10, 10)//passing value
}

fun main() {
    //passing function as parameter
    var x = 10;
    var y = 20
    add(x, y)//pass variable
    add(10, 10) //pass value- literal
    var sayHello: () -> Unit = fun() {
        println("Hello")
    }
    //function as parameter
    sayGreet(sayHello)
    //function itself passed directly.
    sayGreet(fun() {
        println("Hai")
    })
    adder(fun(a: Int, b: Int): Unit {
        var r = a + b
        println("Result of Adder ${r}")
    })
}
.....................................................................................

More Complex Example:
package com.mycom.functionalprogramming.hof

//how to pass more fun parameters
fun login(userName: String = "", password: String = "", resolve: (String) -> Unit, reject: (String) -> Unit) {
    //biz logic
    if (userName == "admin" && password == "admin")
        resolve("Login Success")
    else
        reject("Login failed")
}

fun main() {
    login(userName = "admin", password = "admin",
        fun(status) {
            println(status)
        },
        fun(err) {
            println(err)
        })
    login(userName = "foo", password = "bar",
        fun(status) {
            println(status)
        },
        fun(err) {
            println(err)
        })
}
.....................................................................................
			Higher order functions and Lambdas
...................................................................................

What is Lambda?
  Lambda terminalogy is derived the Lambda calculs.

Lambdas are function literals only , can be assigned to a variable, passed around(in and around).

How to declare Lambda Expression?

val | var variableName:FunctionType = {arg -> functionBody }

Rules:
1.A lambda expression is always surrounded by curly braces.
2.Parameter declartions in the full synatactic form go inside curly braces and have optional type annotations.
3.The body of the function will go after ->

4.The infered return type is not "Unit" by default , the last line (possibly) expression inside the lambda body is treated as the return value.

5.Lambdas can be passed to another function as parameter or Lambdas can be passed to another Lambdas as parameter.

package com.mycom.functionalprogramming.lambdas

//normal function
fun add(a: Int = 1, b: Int = 1): Int {
    return a + b
}

//function expression:if function has only one line of returned code.
fun addExpression(a: Int = 1, b: Int = 1) = a + b

//function as literal : function can be assigned into a variable
var addFun = fun(a: Int, b: Int): Int {
    return a + b
}

//function as lambda : function can be assigned into a variable
var addLambda = { a: Int, b: Int ->
    //body of the fun expression
    //return a + b //return keyword is not used
    a + b
}

fun main() {
    println(add(10, 10))
    println(addExpression(10, 10))
    println(addFun(10, 10))
    println(addLambda(10,10))
}
...........................**********................................................
				Lambda complex syntaxs


package com.mycom.functionalprogramming.lambdas

//function as lambda : function can be assigned into a variable
var add = { a: Int, b: Int ->
    a + b
}

//mulitple line of code
//with type
var login: (String, String) -> String = { userName: String, password: String ->
    println("Login function is called")
    println("$userName $password")
    if (userName == "admin" && password == "admin")
        "Login Success"
    else
        "Login Failed"

}

//without type: Type inference:Highly recommend
//var auth = { userName: String, password: String ->
//    println("Login function is called")
//    println("$userName $password")
//    if (userName == "admin" && password == "admin")
//        "Login Success"
//    else
//        "Login Failed"
//
//}
var auth = { userName: String, password: String ->
    println("Login function is called")
    println("$userName $password")
    if (userName == "admin" && password == "admin")
        "Login Success"
    else
        "Login Failed"

}

//lambdas has no parameter and no return value
//var myFun: () -> Unit = {
//    println("Hello")
//    println("How are you?")
//    println("What about you")
//}
var myFun = {
    println("Hello")
    println("How are you?")
    println("What about you")
}

/////////////if lambda has single arg and parameter
var sayMyName = { name: String ->
    name.uppercase()
}


fun main() {
    println(add(10, 10))
    println(login("admin", "admin"))
    myFun()
    println(sayMyName("Subramnaian"))

}
.....................................................................................
				it -Variable

"it" is implcit variable can be used in lambda to replace single explicit arg functions

package com.mycom.functionalprogramming.lambdas


/////////////if lambda has single arg and parameter
var sayMyName = { name: String ->
    name.uppercase()
}

//name variable can be replaced with "it" variable
var sayYourName: (String) -> String = { it.uppercase() }

fun main() {
    println(sayYourName("Subramnaian"))
}
...................................................................................
			Higher order function and Lambdas
...................................................................................

How to pass lambda as parameter to another function or lambda?

package com.mycom.functionalprogramming.lambdas

fun delay(action: () -> Unit) {
    action()
}

fun main() {

    //passing regular function as parameter
    delay(fun() {
        println("delay")
    })
    //passing lambda
    var task = {
        println("Task")
    }
    delay(task)
    //passing lambda as literal directly
    delay({
        println("Task is more")
    })

}
.....................................................................................					DSL - Domain Specific Language
.....................................................................................

More readable code english like statement.
Kotlin supports building dsl syntax.

Basic DSL syntax:

When pass lambda as parameter to the function, we can ommit ()

   //lambda skips ()
    delay {
        println("DSL task")
    }
...................................................................................
		If higher order function takes more parameters(mixed)
			
fun compute(no: Int = 0, action: () -> Unit) {
    println("no ${no}")
    action()
}
fun main() {
    compute(10, { println("Compute") })
}

DSL Syntax for more parameters:
...............................
When you pass lambda as second parameter, the first parameter can be enclosed with "()" and second parameter(lambda) can passed directly.
fun compute(no: Int = 0, action: () -> Unit) {
    println("no ${no}")
    action()
}

fun filterBy(order: String = "asc", name: String = "name", no: Int = 0, action: () -> Unit) {
    println("Order ${order} Name ${name} no ${no} ")
    action()
}
fun main() {
    compute(10, { println("Compute") })
//dsl syntax
    compute(10) { println("Compute WITH DSL") }

   filterBy(order = "desc", name = "John", no = 100) {
        println("Filter is done")
    }

}
   
Most of the Kotlin functions powered with "Lambda" -Higher order

//built in function called
    thread(name = "My Sweet Thread", start = true) {
        println(" Current Thread ${Thread.currentThread().name}")
    }
    thread(name = "Product Thread", start = true) {
        Thread.sleep(1000)
        println(" Current Thread ${Thread.currentThread().name}")
    }
....................................................................................
			 Best Practices Designing With Lambda

We can lambda at places of function calls,but it does not give you DSL syntax.

 filterBy(action = { println("filter is over ") }, name = "Product")

Recommendation is always pass lambda as last parameter.
.....................................................................................			    It variable in the Higher order function
....................................................................................

package com.mycom.functionalprogramming.lambdas


fun doubleIt(n: Int = 0, action: (Int) -> Unit) {
    //double the input and send the result via lambda
    action(n * 2)
}

fun add(a: Int = 0, b: Int = 0, c: Int = 0, action: (Int) -> Unit) {
    action(a + b + c)
}

//return values from the lambda
fun multiply(a: Int = 0, b: Int = 0, action: (Int) -> Int) {
    var result = action(a * b)
    println("Returned Result from the Calleer $result")
}

fun main() {
    doubleIt(10) { res -> println("Result is $res") }
    doubleIt(10) { println("Result is $it") }
    add(a = 10, b = 30, c = 80) { println("Result is $it") }

    //return value from the lambda, no return statement , last line of lambda is return
    multiply(a = 10, b = 10) { res ->
        println("Multiply function")
        res
    }
    //refactor the code with it
    multiply(a = 10, b = 10) {
        println("Multiply function")
        it
    }

}
....................................................................................
			How to pass more no of lambda parameters
....................................................................................

package com.mycom.functionalprogramming.lambdas

fun login(
    userName: String = "",
    password: String = "",
    resolve: (String) -> Unit,
    reject: (String) -> Unit
) {
    if (userName == "admin") resolve("Login Success") else reject("Login failed")
}


fun main() {
    login(userName = "admin",
        password = "admin",
        resolve = { println(it) },
        reject = { println(it) })
}
.....................................................................................
		What if The lambda is taking More parameters

fun doCompute(a: Int = 0, b: Int = 0, action: (Int, Int) -> Unit) {
    action(a, b)
}

fun main() {
    login(userName = "admin",
        password = "admin",
        resolve = { println(it) },
        reject = { println(it) })

  
    doCompute(a = 10, b = 20) { a, b -> println("$a $b") }
    //how to skip parameters
    doCompute() { a, b -> println("$a $b") }
    //kotlin automatically skips parameters and initialized with default values
    doCompute { a, b -> println("$a $b") }
}
....................................................................................
			 Can we skip lambda args
.....................................................................................

Yes!
We can use "_" notation instead of its name


 package com.mycom.functionalprogramming.lambdas

fun doCompute(a: Int = 0, b: Int = 0, action: (Int, Int) -> Unit) {
    action(a, b)
}


fun main() {
      //I need here only b value not a value.we can use _ notation
    doCompute { _, b -> println("$b") }
    doCompute(b = 10) { _, b -> println("$b") }


}
.....................................................................................
		How to pass a lambda as parameter to another lambda
...................................................................................
var async = { action: (String) -> Unit ->
    action("async function")
}

fun main() {
  async { println(it) }
}

More parameters with Lambda:

package com.mycom.functionalprogramming.lambdas

var async = { payload: String, action: (String) -> Unit ->
    action(payload)
}

fun main() {
    async("My async task is running...") { println(it) }
}
.....................................................................................
	   Object oriented Programming and implementation
.....................................................................................

What is Object orientation?
   "The Object orientation is way/style  of building applications"

if take any Program, there are only two things
    -Data - information
    -How to operate on the data

Data represents the problem domain- Banking

Program = { Data  +  actions/operations }

Before OO:
  data   |  operations are completly isloated  = traditional programming styles - procedural style

 if many operations operate on data, which lead inconsistency,data corrpution/loss, 
 data duplication.....

1970's white paper was published regarding, How to orgainize the data based problem(domain)-real world.

We need to map the data according to realworld problems what we solve using machines/programs.

Birth of Abstract Data Type of theory:
......................................

  To create new data types based on core types.

core types:
    numbers, characters
    numbers- very very core.

Language types
    int,float,char -primitive types

NewType = { int,float,int,char,char }
  |
Abstract Data Type

Implementation of Abstract data type Theroy:

In c language , abstract data type theroy were implemented via notations 

1.struct
2.union
   These notation grouped data into a logical unit.
3.class
    The class word dervied from "clause" 
   Grouping of things(data).

Based on this notatation, c language introduced a concept called "c with classes"
that later led into a new programming style and implementation 
    -Object oriented Programming 
        Object means the realworld problem domain having data 
implementation was XXX,c with classses(c++)

OO talks about how to organize data and its operations togther

 Object | class = {data + operations}

Based on class and Objects , Principles were published /  Object oriented Concepts
..................................................................................
1.Abstraction
2.Encapsulation
3.Typing
4.Hierachy
5.Modularity
.....................
6.Concurrency
7.Persistency

1.Abstraction:
    Abstraction theory talks data collection from the problem domain called "Object".
  
 Abstraction says how to extract "necessary data" from the object on given context.   

eg:
   if you take Mr.x,
He goes to the bank,What type of information(data) the banker needs.
 -Mr.X as Customer
   -CutomerId
   -CustomerName
   -address
   -email,phoneno
   -type of account
   -balance
   etc....

Abstraction collects data and organize under single unit called "class"

How to declare class in Kotlin?

class Customer {
    //data - properties
    var customerId:Int
}

Compile Time error:
Property must be initialized or be abstract

Note: In Java if any instance variable(property) , not initalized, woulde be null by default.
You know very well ,Kotlin by default cant have null.

class Customer {
    //data - properties
    var customerId: Int? = null
    var firstName: String? = null
    var lastName: String? = null
    var city: String? = null
    var balance: Double? = null
}

Memory Allocation:
..................
 The program  during runtime,when is loaded into main memory.

We need to allocate memory for variables,methods....

if you allocate memory for group of variables, called "instance/object". - instance creation.

package com.mycom.oo

class Customer {
    //data - properties
    var customerId: Int? = null
    var firstName: String? = null
    var lastName: String? = null
    var city: String? = null
    var balance: Double? = null
}
package com.mycom.oo

fun main() {
    //here customer is variable points the instance , called as reference variable
    //var is keyword
    //:Customer is type - custom Type /Abstract type
    //Customer() - constructor call which indicates memory allocation
    //In kotlin no new keyword, provided by the compiler
//    var customer:Customer = Customer() //with explcity
    var customer = Customer() //with Type inference
    //property initalization
    customer.customerId = 1
    customer.firstName = "Subramanian"
    customer.lastName = "Murugan"
    customer.city = "Coimbatore"
    customer.balance = 19887.00
    //access property
    println("Id ${customer.customerId}")
    println("Name ${customer.firstName} ${customer.lastName}")
    println("City ${customer.city}")
    println("Balance ${customer.balance}")

}
....................................................................................
			   variable declarations

1.using var keyword - can be reinitalized
2.using val keyword - cant be reinitalized - immutable variables
   The original memory address can't be overriden.
  
package com.mycom.oo

fun main() {
    var x = 10
    println("X $x")
    //x value is reinitialized
    x = 90
    println("X $x")
    val y = 10
    println("Y $y")
    //val cant be reinitlized
    //y=90
    println("Y $y")


}

.....................................................................................
			 State(data-properties) Initalization
.....................................................................................
1.Inside class
2.outside class after object creation via reference variable
3.during object creation - constructors


Inside class:

Direct assignment:
package com.mycom.oo

class Employee {
    //property initialization - inside class directly
    var employeeId: Int? = 0
}
package com.mycom.oo

fun main(){
    var employee = Employee()
    println("Id ${employee.employeeId}")
}

via init block:
init is special block used to initalize the variables and any code.
A Single class can have mulitple init blocks but recommended having only one init block
init blocks are getting executed the order in which they declared

package com.mycom.oo

class Employee {
    //property initialization - inside class directly
    //var employeeId: Int? = 0
    var employeeId: Int?

    //init block
    init {
        println("init block -1")
        employeeId = 0
    }

    init {
        println("init block-2 ")
    }

    init {
        println("init block 3")
    }
}
..................................................................................
			Outside class 

package com.mycom.oo

fun main(){
    var employee = Employee()

    println("Id ${employee.employeeId}")
    //outside class :
    employee.employeeId =100
    println("Id ${employee.employeeId}")
}

In java , all instance variables either initalized via constructors or setters

Setters :Mutatators:
...................
1. It is a Special method, used to initalize the properties
2.It is part of java bean specification.

Kotlin and setters:
..................
1.Kotlin does not recommended to have setters by default.
2.Kotlin uses implicit setters by default.
employee.employeeId =100
 In this code, setters are called implicitly.

Getters : Accessors:
...................
1.It is Special method , used to read the properites
2.It is part of java bean specification.

Kotlin and getters:
..................
1.Kotlin does not recommended to have getters by default.
2.Kotlin uses implicit getters by default.
 println(employee.employeeId)
 In this code, getters are called implicitly.


Can we have explcit getters and setters?

 Yes!

Syntax:
 var <propertyName> :[<PropertyType>] = [<property_initalizer>]
 [getter]
 [setter]
 
eg:
package com.mycom.oo

class User {
    var name: String? = null
        set(value) {
            //backing fields
            field = "Mr/Mrs $value"
        }
        get() {
            return field?.uppercase()
        }
    var age: Int? = null
        set(value) {
            //Age must be greater than 18
            if (value?.compareTo(18)!! < 0) {
                throw Exception("Age must be greater than 18")
            } else {
                field = value
            }
        }
}

package com.mycom.oo

fun main() {
    val user = User()
    user.name = "Subramanian"
    user.age =10
    println(user.name)
    println(user.age)

}

Here exception is thrown when age is less than 18.
Exception in thread "main" java.lang.Exception: Age must be greater than 18
	at com.mycom.oo.User.setAge(User.kt:16)
	at com.mycom.oo.PropertyInitalizationV2Kt.main(PropertyInitalizationV2.kt:6)
	at com.mycom.oo.PropertyInitalizationV2Kt.main(PropertyInitalizationV2.kt)


package com.mycom.oo

fun main() {
    val user = User()
    user.name = "Subramanian"
    user.age =19
    println(user.name)
    println(user.age)

}
Here the out put is shown.
MR/MRS SUBRAMANIAN
19

Computed Property:
  The combining more variables and producing an expression.


package com.mycom.oo
class User {
    var firstName: String? = null
    var lastName: String? = null
    //computed Property syntax
    var fullName: String = ""
        get() {
            return "${this.firstName} ${this.lastName}"
        }


}

package com.mycom.oo

fun main() {
    val user = User()
    user.firstName ="Subramanian"
    user.lastName ="Murugan"
    println("Full Name ${user.fullName}") 

}
.....................................................................................
			  Getters are Function expression syntax
.....................................................................................

package com.mycom.oo

class User {
    var name: String? = null
        set(value) {
            //backing fields
            field = "Mr/Mrs $value"
        }
        //        get() {
//            return field?.uppercase()
//        }
        //function expression syntax
        get() = field?.uppercase()

    var firstName: String? = null
    var lastName: String? = null

    //computed Property syntax
    var fullName: String = ""
        //        get() {
//            return "${this.firstName} ${this.lastName}"
//        }
        get() = "${this.firstName} ${this.lastName}"

   
}
.....................................................................................
	How to initalize the property during object creation?
			constructors

Constructors are special methods are used to initalize the object properties during object /instance creation.
			 
properties are declared in kotlin in two ways

1.inside class
class User{
  var name:String? =null
}
2.as part of Constructor.

Types of Constructors:
.....................
1.Primary constructor
2.Secondary constructor.

Primary constructors are default constructors
Secondary constructors are used for overloading.

Primary constructors:
 -primary constructors are added as part of class header.

class ClassName constructor(){}

 Note:
  if the primary constructor does not have any annotations or visibility modifers, the constructor keyword can be omitted.

class ClassName (){}
class ClassName [private | @Something] constructor(){}

Primary constructors does not contain any code, if you want any special initalization ,should be given inside "init block


package com.mycom.oo.constru

class Person constructor(var firstName: String = "", val age: Int = 0) {
}
package com.mycom.oo.constru

fun main() {
    val person = Person(firstName = "Subramanian", age = 19)
    println("Name ${person.firstName} Age  ${person.age}")
}

..............

without constructor keyword:
.............................

package com.mycom.oo.constru
class Person(var firstName: String = "", var age: Int = 0) {
}

...
Constructors and init block:
............................
package com.mycom.oo.constru

class Person(var firstName: String = "", var age: Int) {
    init {
        age = 18
    }
}
...................................................................................
			Secondary Constructors
..................................................................................
A class can have more constructors apart from the primary constructors, generally to mimic the overloading.

A secondary constructors are introduced inside class using constructor keyword.

Eg:
package com.mycom.oo.constru

class Foo constructor() {
    //secondary constructors
    constructor(a:String){
        
    }
    
}
Here the compile time error

Primary constructor call expected

package com.mycom.oo.constru

class Foo constructor() {
    //secondary constructors
    //invoke always primary constructor
    constructor(a: String) : this() {
        println("Constructor with String arg")
    }
    constructor(b: Int) : this() {
        println("Constructor with Int  arg")
    }
    constructor(a:Int,b:Int):this(){
        println("Constructor with Int, Int arg")
    }
}

Note:
   Each secondary constructor needs to delegate to the primary constructors either directly or indirectly through another secondary constructors.
Delegation to another constructor for same class is done using "this" keyword.

...................................................................................

Primary constructor can't have any code, suppose if you want  to add any extra code
that be can be done using secondary constructors


package com.mycom.oo.constru


class Employee(var name: String, var age: Int) {
    constructor(age: Int, name: String) : this(name,age) {
        println("some extra code is being executed inside constructor")
    }
}
package com.mycom.oo.constru

fun main() {
   
    var employee = Employee(41,"Subramanian")
}
.....................................................................................
			 Class Members
.....................................................................................
A class can contain many things

1.constructors and iniitalizer blocks
2.properties
3.functions
4.Nested and inner classes
5.Object declartions.


functions inside class:
package com.mycom.oo.classfunctions

class EmployeeService {

    //methods or functions
    fun findAll(): String {
        return "findAll"
    }

    fun save(employee: String): Boolean {
        println("$employee is saved")
        return true
    }

    // single expression function
    fun remove(id: Int) = "$id Removed"
}
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,

package com.mycom.oo.classfunctions

fun main(){
    var employeeService = EmployeeService()
    println (employeeService.findAll())
    println(employeeService.save("foo"))
    println(employeeService.remove(10))
}
.....................................................................................
			class memebers - functions-higher order,lambda 

A class can contain all the form of functions.

package com.mycom.oo.classfunctions

class Util {

    //normal function
    fun sayHai(): Unit {
        println("Hai")
    }

    //literal function declaration
    var sayHello: () -> Unit = fun() {
        println("Hello")
    }

    //higher order function
    fun login(userName: String = "", password: String = "", resolve: (String) -> Unit, reject: (String) -> Unit) {
        //biz logic
        if (userName == "admin" && password == "admin")
            resolve("Login Success")
        else
            reject("Login failed")
    }

    //lambda expression
    var addLambda = { a: Int, b: Int ->
        //body of the fun expression
        //return a + b //return keyword is not used
        a + b
    }

    //higher order lambdas
    fun delay(action: () -> Unit) {
        action()
    }
    //higher order lambda: passing lambda as parameter to another lambda
    var async = { action: (String) -> Unit ->
        action("async function")
    }
}
.........
package com.mycom.oo.classfunctions

fun main() {
    var util = Util()
    //normal function
    util.sayHai()
    //literal functions
    util.sayHello()
    //higher order function
    util.login(userName = "admin", password = "admin",
        fun(status) {
            println(status)
        },
        fun(err) {
            println(err)
        })
    //lambda
    println(util.addLambda(10, 10))
    //higher order lambda
    util.delay { println("Task is more") }

    //higher order lambda but passing lambda as parameter
    util.async { println(it) }

}
...................................................................................
				Dynamic Programming
				
In java, if you declare methods inside class, only those methods only can be used after instance creation.

//Util.java
public class Util{
    public void add(){

    }   
}
Util util = new Util()
util.add()

here apart from "add" method we cant use other methods.

Some languages(javascript,groovy) offers a feature to add method dynamically/during runtime without explcitly declaring inside class - "dynamic programming"

Kotlin provides the ability to extend(add) a class or interface with new functionality without having to inherit or use any design patterns like "decorator".
This is done via special declarations called "extensions".

Use case:
if you are using third party libs/frameworks that you cant modify, if you want to add any special apis, you can do that.

You can call that functions as if they were methods of the original class - "This is called as Extension function".

Not only methods even you can add properties too  - Extension Property

Extension Functions:
...................

To declare extension function, the prefix its name with a "receiver type" which referes to the type being extended


fun ReceiverType.method(args):{
   //function body
}

package com.mycom.oo.dynamicprogramming

class Util {
    //member function
    fun sayHello():String {
        return "Hello"
    }
}
..
package com.mycom.oo.dynamicprogramming

//extensions
fun Util.sayHai(): String {
    return "Hai"
}

fun main() {
    var util = Util();
    //calling member function
    println(util.sayHello())
    println(util.sayHai())
}
...................................................................................
		Can we extend any built in classes?

Yes, if you look at in java, String is final class, meaning that you cant extend(inherit) the class, so you cant have your own string apis.
Thats where extension functions comes into picture.

package com.mycom.oo.dynamicprogramming

//extensions
fun Util.sayHai(): String {
    return "Hai"
}

fun String.add(s1: String, s2: String): String {
    //this refers the method is called on which object
    return this + s1 + s2
}

fun main() {
    var util = Util();
    //calling member function
    println(util.sayHello())
    println(util.sayHai())
    //strings
    var str1: String = "Hello"
    var str2: String = "Hai"
    var str3 = "Hey"
    //str3 is receiver type
    println(str3.add(str1, str2))

}
......................................................................
				Extension Properties
...................................................................................
package com.mycom.oo.dynamicprogramming

class MyUtil {
}

//adding new Property outside class
val MyUtil.greetings:String
  get() = "Hello"

fun main() {
    var util = MyUtil()
    println(util.greetings)
}
.....................................................................................					Infix function
.....................................................................................

What is Infix function?

Functions are marked with the keyword called "infix".
Infix functions are used to create DSL based code, we can omit the parenteses.

class A {
 infix fun doStuff(x:Int){}
}
val a = A()

a.doStuff(10)

a doStuff 10

"hello" indexof 1

Rules:
1.It must be member functions or extensions functions
2.They must have single parameter
3.The parameter must not accept variable number of args and must have no default value.

package com.mycom.oo.dynamicprogramming

class MyClass {
    infix fun sayHello(name: String) {
        println("$this $name")
    }

}

//infix function can be extension function too
infix fun Int.myadd(x: Int) {
    println(this)
    println(x)
}

fun main() {
    //omitting parentheses
    10 myadd 2
    val greeter = MyClass()
    greeter sayHello "Subramanian"

}
....................................................................................
			 Member functions calling pattern
...................................................................................

Member function can be called using reference variable
Member function can be called Using Constructor call itself.

package com.mycom.oo.dynamicprogramming

class MyService {
    fun findAll(): String = "findAll"
}

fun main() {
    //using reference variable
    val service = MyService()
    println(service.findAll())
    //using constructors
    println(MyService().findAll())
}
.....................................................................................
			 inline functions
...................................................................................

What is inline?

by inserting the function code at the address of each function call, thereby saving the overhead of a function call

          "copy and paste function code into calling place"

Regular functions call
caller(calling place)
fun foo(){
  doStuff()
}

callee
fun doStuff(){

}

Inlining basically requesting the compiler to copy the (inlined) code at the calling place

Why?
 Avoiding un necessary stack creations so that you can avoid tracking return address,args values....

Kotlin and Inline Functions:
...........................
In Kotlin, the higher order functions and lambdas are represented as "Object" behind the scene.

Since it is object takes some memory and increase the memory overhead if function gets called more no of times.

The use case might be the function does a very basic functionality that passing the control is not even worth as it is being used in multiple places, we need to create a separate function.

in order to reduce memory overhead of such functions we can use the "inline" keyword.

"inline" requests the CPU to not allocate any memory for the functionand simply the copy body of that function at the calling place.



package com.mycom.oo.dynamicprogramming

inline  fun mulitpleOf(no: Int, multipleOf: Int): Boolean {
    return no % multipleOf == 0
}

fun ArrayList<Int>.filterOnCondition(condition: (Int) -> Boolean): ArrayList<Int> {
    var result = arrayListOf<Int>()
    for (item in this) {
        if (condition(item)) {
            result.add(item)
        }
    }
    return result
}

fun main() {
    var list = arrayListOf<Int>()
    for (n in 1..1000) {
        list.add(n)
    }
    //passing function as parameter:
    var result = list.filterOnCondition { mulitpleOf(it, 5) }
    println(result)

}

Note;
 if function having more logic that is more lines of code , dont mark inline.
....................................................................................
			Hierachy - Object Relationship
....................................................................................
There are two types of Hierachy:

1.HAS -A - Composition
2.IS -A - Inheritance.

Code Reuse Patterns:
1.inheritance
2.compostion

IS A: Inheritance:
..................

What is inheritance? Why Inheritance?

Code Reuse,To avoid code duplication across the application, having common that can be shared.

Inheritance Code Reuse Implementations:
.......................................
1.class - concrete class
2.interfaces
3.Abstract classes

Parent class and child class


Kotlin and inheritance:

In kotlin all classes are freezed by default for extension(inheritance).
Inheritance is disabled by default.
In Kotlin all classes are "final classes" by default.


Syntax:

class MyClass : BaseClass(){

}

class Animal{

}
class Dog :Animal() {

}

compile time error:
This type is final, so it cannot be inherited from

if any class is to be extended it has to be marked as "open"

package com.mycom.oo.hierachy.`is`


package com.mycom.oo.hierachy.`is`


open class Animal {
    init {
        println("Animal class is called")
    }
}

class Dog : Animal() {
    init {
        println("Dog class is called")
    }
}


fun main() {
    var dog = Dog()

}
....................................................................................
			   Typing 


How the reference variables going to bind the expressions during compile time and runtime?

var myref = Dog()

Dog myref= Dog()

Polymorphism:
  
Compile time  
   The reference variable binds the properties and methods during compile time
 This method belongs to this Type
 var myref = Dog()
 myref.bark()
 myref.something()

Run time 
  The runtime calls the implmentation side, the object side.
 The program  to super type

The reference variable type can be same type or its parent Type...


 eg:
package com.mycom.oo.typing

open class Animal {
    fun eat(): String {
        return "Animal eats"
    }
}

class Dog : Animal() {

}

fun main() {
    //here type of animal variable is Dog : Program to concrete type/type
    var animal = Dog();
    println(animal.eat())
}

output:
Animal eats

How that method is avaiable inside Dog class , even though the method is represented inside "Animal" class.

Inheritance happens always in compile time.

source coe
Animal.kt
open class Animal {
    fun eat(): String {
        return "Animal eats"
    }
}

Dog.kt
class Dog : Animal() {

}
After compilation:
Animal.class
class Animal {
    public String eat() {
        return "Animal eats"
    }
}

Dog.class
class Dog extends Animal {
    public String eat() {
        return super.eat()
    }
}

var animal = Dog();
println(animal.eat())

...
How to implment eat method in the Dog class?

 This is called overriding.

In kotlin all methods are by default "final" - cant be overriden.

if you want to override the method, you have to open it
in the dervied class we have to use "override" keyword.

package com.mycom.oo.typing

open class Animal {
    open fun eat(): String {
        return "Animal eats"
    }
}

class Dog : Animal() {
    //overriding
    override fun eat(): String {
        return "Dog eats"
    }
}

fun main() {
    //here type of animal variable is Dog : Program to concrete type/type
    var animal = Dog();
    println(animal.eat())
}
.....................................................................................
			 Program to Super Type
....................................................................................
package com.mycom.oo.typing

open class Animal {
    open fun eat(): String {
        return "Animal eats"
    }
}

class Dog : Animal() {
    //overriding
    override fun eat(): String {
        return "Dog eats"
    }
}

fun main() {
     //super type
    var animal1: Animal = Dog();
    println(animal1.eat())
}
.....................................................................................
			  Super type and Sub type
....................................................................................
package com.mycom.oo.typing

open class Animal {
    open fun eat(): String {
        return "Animal eats"
    }
}

class Dog : Animal() {
    //overriding
    override fun eat(): String {
        return "Dog eats"
    }

    //Dog specific method
    fun bark(): String {
        return "Dog barks"
    }
}

/**
 * during compile time the compiler looks left Side(type) for method expression bindings
 * during runtime time the run time looks right side(Instance) for method invocation -Dynamic
 * method invocation/ Dynamic method dispatch... :Runtime polymorphism
 */
fun main() {
    //here type of animal variable is Dog : Program to concrete type/type
    var animal = Dog();
    println(animal.eat())
    println(animal.bark())
    //super type
    var animal1: Animal = Dog();
    println(animal1.eat())
    //Here this compile error time
    //println(animal1.bark())
    
}
 
How to invoke sub class method using parent Type?

Solution is "Type Casting"
We have to convert Animal type to Dog type - Down casting.

package com.mycom.oo.typing

open class Animal {
    open fun eat(): String {
        return "Animal eats"
    }
}

class Dog : Animal() {
    //overriding
    override fun eat(): String {
        return "Dog eats"
    }

    //Dog specific method
    fun bark(): String {
        return "Dog barks"
    }
}

/**
 * during compile time the compiler looks left Side(type) for method expression bindings
 * during runtime time the run time looks right side(Instance) for method invocation -Dynamic
 * method invocation/ Dynamic method dispatch... :Runtime polymorphism
 */
fun main() {
    //here type of animal variable is Dog : Program to concrete type/type
    var animal = Dog();
    println(animal.eat())
    println(animal.bark())
    //super type
    var animal1: Animal = Dog();
    println(animal1.eat())
    //Here this compile error time
    //println(animal1.bark())
    //how to call
    //convert animal type to Dog type
    var tmpDog = animal1 as Dog
    println(tmpDog.bark())

}
....................................................................................
			 How to override properties
...................................................................................

package com.mycom.oo.hierachy.`is`

open class Shape {
    open val x: Int = 0
}

class Square : Shape() {
    override val x: Int = 10
}

fun main() {
    var shape = Square()
    println(shape.x)
}
...................................................................................
		 How to call Super class properties and methods
package com.mycom.oo.hierachy.isa

open class Account {
    open fun deposit(): Int {
        return 100
    }
    val accountType:String get() = "Account Type"
}
class SavingsAccount:Account() {
    override fun deposit(): Int {
        return super.deposit() * 1000
    }
    val accType:String get() = "${super.accountType} is Savings Account"

}
fun  main(){
    val sb = SavingsAccount()
    println(sb.deposit())
    println(sb.accType)
}
.....................................................................................
			  Interfaces
.....................................................................................

interfaces are used to share code "across multiple hierachies" where as the classes are used to share code only to particular type.

classes based hierachy:
  Single family 
eg : Animal

    Animal
      |
     eat

 Dog 
 Cat

interface based hierachy
  Multiple family of classes
  
    Eatable
      eat
  |     |      |
Animal Birds Humans
.....................................................................................
	                  Interfaces with implmentation
package com.mycom.oo.hierachy.isa.interfaces

interface Eatable {
    //open fun eat(): String;
    fun eat(): String;
}

//implmentation
class Dog : Eatable {
    override fun eat(): String {
        return "Dog Eats"
    }

    fun bark(): String {
        return "Bark"
    }
}

class Duck : Eatable {
    override fun eat(): String {
        return "Duck Eats"
    }
    fun swim():String {
        return "swim"
    }
}


fun main() {
    //concrete type
    val dog = Dog()
    println(dog.eat())
    val duck = Duck()
    println(duck.eat())
    //polymorphism : Super type

    var eatableBehaviour: Eatable? = null
    //Dog implmenation
    eatableBehaviour = Dog()
    println(eatableBehaviour.eat())
    //smart casting happens
    println(eatableBehaviour.bark())
    //Duck implmenation
    eatableBehaviour = Duck()
    println(eatableBehaviour.eat())
    println(eatableBehaviour.swim())

}

Note: 
 In the code we have not done explicit casting in order to call implmentation instance
  "Kotlin will take of casting automatically Which is called "Smart casting".
  This is applicable only to interfcase
..............................................................................
 			Multiple interfaces and inheritance
.....................................................................................
package com.mycom.oo.hierachy.isa.interfaces

interface Eat {
    fun eat():String
}
interface Walk  {
    fun walk():String
}
class Cat : Eat,Walk {
    override fun eat(): String {
        return "Eat"
    }

    override fun walk(): String {
       return "Walk"
    }
}

fun main(){
    var cat = Cat();
    println(cat.eat())
    println(cat.walk())
}
..................................................................................
			Method Conflicts in multiple interfaces
			  and How to resolve them


package com.mycom.oo.hierachy.isa.interfaces

interface Interface1 {
    fun doStuff(): String
}

interface Interface2 {
    fun doStuff(): String
}

class Implementator : Interface1, Interface2 {
    override fun doStuff(): String {
        return "Implementor"
    }
}

fun main() {
    var myvar = Implementator()
    println(myvar.doStuff())
}
....................................................................................
			Interfaces and Implmentations

Interface can have implementations too, what if method duplications?

The implementor class must provide default implementation and inside that implmentation we need to call method "super<Interface1>.foo()"

package com.mycom.oo.hierachy.isa.interfaces

interface Interface1 {
    fun doStuff(): String
    fun foo(){
        println("foo Interface1")
    }
}

interface Interface2 {
    fun doStuff(): String
    fun foo(){
        println("foo Interface2")
    }
}

class Implementator : Interface1, Interface2 {
    override fun doStuff(): String {
        return "Implementor"
    }

    override fun foo() {
        super<Interface2>.foo()
    }
}

fun main() {
    var myvar = Implementator()
    println(myvar.doStuff())
    myvar.foo()

}
....................................................................................
			Functional Interfaces-SAM

There are two implementations of SAM

1.java style
   -Using anonmous inner class Pattern
2.kotlin style
   We have to declare with fun keyword.

Inside interface if you declare methods, those methods are called as "abstract methods" 
interface Interface1 {
    //abstract methods
    fun doStuff(): String
}
abstract methods are methods without implmentations.

if an interface having single abstract method, that interface is called "SAM" -  Single Abstract method.

SAM interfaces are used inside lambda expressions.


if you wanto implement interface , you need class, using functional interfaces you dont need to provide a separte class rather we object anomous inner class.

package com.mycom.oo.hierachy.isa.interfaces

interface Greeter {
    fun greet(): Unit
}

//class GreeterImpl : Greeter {
//    override fun greet() {
//        println("Greet")
//    }
//}

fun main() {
//    var greet = GreeterImpl()
    //    greet.greet()

    //anonymous implementation
    var greet = object : Greeter {
        override fun greet() {
            println("Greet")
        }
    }
    greet.greet()
}

......

Kotlin style:

fun interface Hello(){ 
   fun sayHello():Unit
}
package com.mycom.oo.hierachy.isa.interfaces


//Kotlin Style

fun interface Hello {
    //single abstract method
    fun sayHello(): Unit
}

//
fun interface Predicate {
    fun accept(i: Int): Boolean
}

fun main() {
   //anonymous implementation
    var hello = object : Hello {
        override fun sayHello(): Unit {
            println("Hello Anonmous pattern")
            //return ""
        }
    }
    hello.sayHello()
    //Lambda expression
    var hello1 = Hello { println("Hello lambda ") }
    hello1.sayHello()
    var isEven = Predicate { it % 2 == 0 }
    print(isEven.accept(3))
}
....................................................................................
			  HAS-A
..................................................................................

Composition:
   Object linking


package com.mycom.oo.hierachy.hasa


class Address(var street: String = "street", var city: String = "city") {

}

//has-a
class Employee(var id: Int = 0, var name: String = "name", var address: Address = Address()) {

}

fun main() {
    var emp = Employee(id = 10, name = "Subramanian", address = Address(street = "10th street", city = "Coimbatore"));
    println(emp.id)
    println(emp.name)
    println(emp.address.street + emp.address.city)
}
....................................................................................
IS a - Inheritance happens during compile time
HAS A - happens during runtime
....................................................................................
				Encapsulation
...................................................................................

How to share and how to restrict code from one class and one package to class and another package

Visibility modifers are keywords to restrict code sharing.

What can be the code?
 code can be "class,objects,interfaces,constructors,functions, properties and its setters and getters".

modifers:
 private,protected,internal and public.

The default modifier is public.
.....................................................................................
			        Modularity 
....................................................................................
  
How to organize the code?

In java eco system,Code is organized into folders and files at low level(disk level)
and into packages and subpackages at logical level(memory)

When we organize code, we have to define rules for how to share and how to restrict
 -Encapsulation

Modularity:

package statement

class
fun
interfaces 
variables

what is naming standard for packages?

com.companyName.moduleName.subModule
 |     
company 

org.organzationName.moduleName.subModule

DNS naming standards

package com.google.android;
package android.core.lib;

Types of packages:

1.custom package
   package defined by developers
2.built in packages 
  packages provided by language
3.thrid party packages
  packages provided by third community - frameworks,libs


Built in Packages for kotlin:
.............................

package kotlin

 This core package which is eq in java , java.lang package

pacakge kotlin.collections
   Which offers all data structures used by languge

package kotlin.concurrent
   Basic thread functionality

package kotlin.coroutines
    Async programming

package kotlin.io
     io apis for reading,writing data from and to files,streams


Core Package's Types : kotlin
...............................

Any :
   It is root of every kotlin class. which is eq to java.lang.Object
  
This class offers

1.equals
2.hashcode
3.toString

toString:
 Returns the String representation of object. by default "Any" class has logic
like below

com.mycom.oo.builtinpacks.Greeting@880ec60
 | 
packageName.className@Hashcode

package com.mycom.oo.builtinpacks

class Greeting {

}

fun main(){
    var greeting = Greeting()
    println(greeting.toString())
}

overriding to string method:

package com.mycom.oo.builtinpacks

class Greeting {
    var name = "Subramanian";

    override fun toString(): String {
        return "name  [$name]";
    }
}

fun main() {
    var greeting = Greeting()
    println(greeting.toString())
}
.....................................................................................
equals:
  Compare two objects says that whether objects are equal or not.

package com.mycom.oo.builtinpacks

class Square(val side: Int) {

}

fun main() {
    val square1 = Square(10)
    val square2 = Square(10)
    val isEqual = square1.equals(square2)
    println(isEqual)
}
output:
false

How equals methods returns false?
 Any class has method which always returns false.

in order to compare objects, we need to override equals method.

Object equality is done via comparing object properties only
for eg in Employee, each employee is identified by employeeId....
if two objects employeeId is same , objects are same or Objects are different..

package com.mycom.oo.builtinpacks

class Square(val side: Int) {
    //override the equals methods and say that object equality
    override fun equals(other: Any?): Boolean {
        if (other is Square) {
            return other.side == side
        }
        return false;
    }
}

fun main() {
    val square1 = Square(10)
    val square2 = Square(10)
    val isEqual = square1.equals(square2)
    println(isEqual)
}
...................................................................................
			 Object Comparsions using == operator
.....................................................................................

package com.mycom.oo.builtinpacks

class Square(val side: Int) {
    //override the equals methods and say that object equality
    override fun equals(other: Any?): Boolean {
        if (other is Square) {
            return other.side == side
        }
        return false;
    }
}

fun main() {
    val square1 = Square(10)
    val square2 = Square(10)
    val isEqual = square1.equals(square2)
    println(isEqual)

    //equal operator
    var isInstanceEqual =  square1 == square2
    println("Instance Equal ${isInstanceEqual}")
}

Note:
 in kotlin equals operator (==) and equals method behaves same...


Kotlin has introduced new operator called "===" which compares the object locations rather than object properties

package com.mycom.oo.builtinpacks

class Square(val side: Int) {
    //override the equals methods and say that object equality
    override fun equals(other: Any?): Boolean {
        if (other is Square) {
            return other.side == side
        }
        return false;
    }
}

fun main() {
    val square1 = Square(10)
    val square2 = Square(10)
    val isEqual = square1.equals(square2)
    println("Equals method ${isEqual}")

    //equal operator
    var isInstanceEqual =  square1 == square2
    println("Instance Equal using == operator ${isInstanceEqual}")

    var isObjectEquals =  square1 === square2
    println("Instance Equal using === ${isObjectEquals}")


}

== is called as "Structural equality" -  object property verification
=== is called as "Referential equality" - object memory location verifcation.

We have invert operator !== and !=

.....................................................................................

hashcode:
 it is unquie no generated by jvm and attached to every instance , in order to identify the objects.

package com.mycom.oo.builtinpacks

class Employee {
    override fun hashCode(): Int {
        return 100*100
    }
}


fun main() {
    var employee = Employee()
    print(employee.hashCode())
}

....................................................................................
Any class:

1.Any can't hold the null value,if you need null to be part of your variable declaration, you can use the type "Any?"
....................................................................................
	     What if i want all methods of Any class overriden in sub class?


"Data Class":
.............
 It is sole purpose as name indicates to hold data.
Data classes can hold standard functionality and some utilty functions such as tostring,hashcode,equals.

how to declare data classes

package com.mycom.oo.builtinpacks

data class User(val name:String,val age:Int)
fun main(){
    var user = User("Subramanian",18);
    println(user.toString())
}

Data classes offers:
1.equals and hashcode pair
2.toString of the form "User(name=Subramanian,age=18")
3.copy method to clone the object safely





















































































































































  


























  
























































